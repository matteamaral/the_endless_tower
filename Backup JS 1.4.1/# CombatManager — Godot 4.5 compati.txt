# CombatManager — Godot 4.5 compatible (no ternaries)
extends Control

@onready var layout : Node = $Layout
@onready var death_panel : Node = $DeathPanel
@onready var boon_panel : Node = $BoonPanel

var top_row : Node = null
var enemies_row : Node = null
var actions_row : Node = null
var combat_log : Node = null
var floor_label : Node = null
var hp_label : Node = null
var energy_label : Node = null
var turn_order : Node = null

var runmgr : Node = null

func _ready() -> void:
	# Resolve optional nodes safely here
	if layout:
		top_row = layout.get_node_or_null("TopRow")
		enemies_row = layout.get_node_or_null("EnemiesRow")
		actions_row = layout.get_node_or_null("ActionsRow")
		turn_order = layout.get_node_or_null("TurnOrder")
		combat_log = layout.get_node_or_null("CombatLog")

		if top_row:
			floor_label = top_row.get_node_or_null("FloorLabel")
			hp_label = top_row.get_node_or_null("HPLabel")
			energy_label = top_row.get_node_or_null("EnergyLabel")

	# Autoload RunManager
	runmgr = get_node_or_null("/root/RunManager")
	if runmgr:
		# connect safely (avoid duplicate connects)
		if not runmgr.is_connected("combat_started", Callable(self, "_on_combat_started")):
			runmgr.connect("combat_started", Callable(self, "_on_combat_started"))
		if not runmgr.is_connected("room_changed", Callable(self, "_on_room_changed")):
			runmgr.connect("room_changed", Callable(self, "_on_room_changed"))
		if not runmgr.is_connected("combat_victory_boon", Callable(self, "_on_combat_victory_boon")):
			runmgr.connect("combat_victory_boon", Callable(self, "_on_combat_victory_boon"))
		if not runmgr.is_connected("run_ended", Callable(self, "_on_run_ended")):
			runmgr.connect("run_ended", Callable(self, "_on_run_ended"))

	# Ensure panels are hidden at start (editor can keep them invisible too)
	if death_panel:
		death_panel.visible = false
	if boon_panel:
		boon_panel.visible = false

	# Wire up rooted BoonPanel Take buttons (if present in scene)
	_setup_boon_buttons()

	_update_hud()


# ----------------- helpers for BoonPanel wiring -----------------
func _setup_boon_buttons() -> void:
	if not boon_panel:
		return
	# path to your choices row, per screenshot: BoonPanel/BoonPanelContainer/BoonVBox/ChoicesRow
	var choices_row = boon_panel.get_node_or_null("BoonPanelContainer/BoonVBox/ChoicesRow")
	if not choices_row:
		return
	# iterate columns -> find Button children and connect
	for i in range(choices_row.get_child_count()):
		var col = choices_row.get_child(i)
		if not col:
			continue
		for j in range(col.get_child_count()):
			var child = col.get_child(j)
			if child and child is Button:
				if not child.is_connected("pressed", Callable(self, "_on_boon_button_pressed")):
					child.connect("pressed", Callable(self, "_on_boon_button_pressed").bind(child))

func _restore_layout_if_hidden() -> void:
	if layout and layout is Control:
		if not layout.visible:
			layout.visible = true
			layout.mouse_filter = Control.MOUSE_FILTER_STOP

func _on_room_changed() -> void:
	# Decide whether Combat layout should be visible
	var should_show_layout : bool = false

	if runmgr and runmgr.RUN:
		var rtype : String = str(runmgr.RUN.get("currentRoom", {}).get("type", ""))
		var in_combat : bool = bool(runmgr.RUN.get("inCombat", false))

		# Only show layout when room is a real combat
		if rtype == "fight" and in_combat:
			should_show_layout = true

		print("CombatManager._on_room_changed() rtype=", rtype, " inCombat=", in_combat, " should_show=", should_show_layout)

	# If we have a layout node (the visible combat UI area) toggle it safely
	if layout and layout is Control:
		if should_show_layout:
			layout.visible = true
			layout.mouse_filter = Control.MOUSE_FILTER_STOP
		else:
			layout.visible = false
			layout.mouse_filter = Control.MOUSE_FILTER_IGNORE

	# Also attempt to hide the whole CombatRoot (parent) as an extra defensive step.
	# This helps if some other rooted panels (death/boon) are siblings that still capture input.
	var mainroot = get_node_or_null("/root/Mainroot")
	if mainroot:
		var cr = mainroot.get_node_or_null("CombatRoot")
		if cr:
			if should_show_layout:
				cr.visible = true
			else:
				cr.visible = false

	# safe updates
	_update_hud()


func _hide_rooted_boon_panel() -> void:
	if boon_panel:
		boon_panel.visible = false

func _show_rooted_boon_panel() -> void:
	# Defensive: only show if runmgr exists and boons are meaningful
	if not boon_panel:
		return
	# If RunManager provides choices, use that to populate dynamic UI externally.
	# For rooted (scene) UI we simply make it visible — metadata on buttons must be set in editor.
	boon_panel.visible = true


# ---------------- signals handlers ----------------

func _on_combat_started() -> void:
	# When combat starts re-show layout (it may have been hidden by death)
	if layout and layout is Control:
		layout.visible = true
		layout.mouse_filter = Control.MOUSE_FILTER_STOP

	# Hide any rooted panels that should not be visible at combat start
	if death_panel:
		death_panel.visible = false
		if death_panel is Control:
			death_panel.mouse_filter = Control.MOUSE_FILTER_IGNORE
	if boon_panel:
		boon_panel.visible = false
		if boon_panel is Control:
			boon_panel.mouse_filter = Control.MOUSE_FILTER_IGNORE

	# Ensure scene-rooted boon buttons are wired (in case scene changed)
	_setup_boon_buttons()

	# Rebuild UI for new combat
	_populate_enemies()
	_build_turn_order()
	_build_actions()
	_update_hud()
	_update_log()


func _on_run_ended() -> void:
	# Basic cleanup and show death or hide UI depending on run state
	if not runmgr or not runmgr.RUN:
		visible = false
		return

	var hero_hp : int = int(runmgr.RUN.get("hero", {}).get("hp", 0))

	# if died -> show DeathPanel (rooted) and make sure underlying layout cannot be interacted with
	if hero_hp <= 0:
		# Defensive: mark run state inactive so other systems stop scheduling actions
		if runmgr and runmgr.RUN:
			runmgr.RUN["active"] = false
			runmgr.RUN["inCombat"] = false
			# if a combat object exists, try to clear inAction flag
			if runmgr.RUN.has("combat") and runmgr.RUN.get("combat", null):
				var cobj = runmgr.RUN["combat"]
				if typeof(cobj) == TYPE_DICTIONARY:
					cobj["inAction"] = false

		# hide the main layout so combat log / buttons don't show through
		if layout and layout is CanvasItem:
			layout.visible = false
			if layout is Control:
				layout.mouse_filter = Control.MOUSE_FILTER_IGNORE

		# show death UI (rooted)
		if death_panel:
			death_panel.visible = true
			# bring to front (if available)
			if death_panel.has_method("raise"):
				death_panel.raise()
			# ensure ReturnBtn exists and is connected
			var ret = death_panel.get_node_or_null("DeathPanelContainer/DeathVBox/ButtonsRow/ReturnBtn")
			if ret and not ret.is_connected("pressed", Callable(self, "_on_death_return_pressed")):
				ret.connect("pressed", Callable(self, "_on_death_return_pressed"))
			# ensure it accepts input
			if death_panel is Control:
				death_panel.mouse_filter = Control.MOUSE_FILTER_STOP

		# clear actions & enemies to avoid interaction
		_clear_children(actions_row)
		_clear_children(enemies_row)

		# ensure combat log notes death
		if combat_log:
			combat_log.text = str(combat_log.text) + "[SYSTEM] You died. Use Return to Lobby.\n"

		# don't hide whole CombatRoot here — we want player to see death_panel (rooted)
		return

	# non-death run end (victory, forced stop)
	_hide_rooted_boon_panel()
	_clear_children(actions_row)
	_clear_children(enemies_row)
	if combat_log:
		combat_log.text = str(combat_log.text) + "[SYSTEM] Run ended. Returning to Title Screen...\n"

	visible = false
	# request main UI show title
	var mainroot = get_node_or_null("/root/Mainroot")
	if mainroot:
		var t = mainroot.get_node_or_null("TitleScreen")
		var cr = mainroot.get_node_or_null("CombatRoot")
		var sbtn = mainroot.get_node_or_null("StartRunBtn")
		if t:
			t.visible = true
		if cr:
			cr.visible = false
		if sbtn:
			sbtn.disabled = false


# ---------------- enemy UI ----------------
func _populate_enemies() -> void:
	if not enemies_row:
		return
	_clear_children(enemies_row)

	if not runmgr or not runmgr.RUN or not runmgr.RUN.get("combat", null):
		return

	var enemies : Array = runmgr.RUN["combat"].get("enemies", [])
	for e in enemies:
		var panel = PanelContainer.new()
		panel.name = str(e.get("id", "enemy"))
		panel.set_meta("enemy_id", e.get("id", ""))
		panel.set_custom_minimum_size(Vector2(200, 96))

		var vb = VBoxContainer.new()
		vb.name = "InnerVBox"
		vb.set_custom_minimum_size(Vector2(180, 88))

		var name_label = Label.new()
		name_label.text = str(e.get("name", "Enemy"))
		name_label.horizontal_alignment = 1 as HorizontalAlignment
		vb.add_child(name_label)

		var hp_bar = ProgressBar.new()
		hp_bar.name = "HPBar"
		hp_bar.min_value = 0
		hp_bar.max_value = float(e.get("maxHp", 1))
		hp_bar.value = float(e.get("hp", 0))
		hp_bar.size_flags_horizontal = Control.SIZE_EXPAND_FILL
		hp_bar.set_custom_minimum_size(Vector2(160, 18))
		vb.add_child(hp_bar)

		var hp_label_node = Label.new()
		hp_label_node.name = "HPLabel"
		hp_label_node.text = "HP: %d / %d" % [int(e.get("hp", 0)), int(e.get("maxHp", 0))]
		hp_label_node.horizontal_alignment = 1 as HorizontalAlignment
		vb.add_child(hp_label_node)

		var hrow = HBoxContainer.new()
		hrow.set_custom_minimum_size(Vector2(180, 28))

		var target_btn = Button.new()
		target_btn.text = "Target"
		target_btn.tooltip_text = "Select this enemy"
		target_btn.set_meta("enemy_id", e.get("id", ""))
		# bind id when connecting
		target_btn.connect("pressed", Callable(self, "_on_enemy_selected").bind(str(e.get("id", ""))))
		hrow.add_child(target_btn)

		var info_btn = Button.new()
		info_btn.text = "Info"
		info_btn.tooltip_text = "Show enemy stats in log"
		if has_method("_on_enemy_info_pressed"):
			info_btn.connect("pressed", Callable(self, "_on_enemy_info_pressed").bind(str(e.get("id", ""))))
		else:
			info_btn.disabled = true

		hrow.add_child(info_btn)

		vb.add_child(hrow)
		panel.add_child(vb)
		enemies_row.add_child(panel)


func _on_enemy_selected(enemy_id: String) -> void:
	if runmgr and runmgr.RUN and runmgr.RUN.get("combat", null):
		runmgr.RUN["combat"]["selected_target_id"] = enemy_id
		_populate_enemies()
		_build_actions()
		_update_hud()


# ---------------- turn order ----------------
func _build_turn_order() -> void:
	if not turn_order:
		return
	_clear_children(turn_order)

	if not runmgr or not runmgr.RUN or not runmgr.RUN.get("combat", null):
		return

	var q = runmgr.RUN["combat"].get("turnQueue", [])
	for t in q:
		var h = HBoxContainer.new()
		var lbl = Label.new()
		if str(t.get("type", "")) == "ally":
			lbl.text = str(runmgr.RUN.get("hero", {}).get("name", "Hero"))
		else:
			lbl.text = _get_enemy_name(str(t.get("id", "")))
		h.add_child(lbl)
		turn_order.add_child(h)


func _get_enemy_name(id: String) -> String:
	if not runmgr or not runmgr.RUN or not runmgr.RUN.get("combat", null):
		return "Enemy"
	for e in runmgr.RUN["combat"].get("enemies", []):
		if str(e.get("id", "")) == id:
			return str(e.get("name", "Enemy"))
	return "Enemy"


# ---------------- actions UI ----------------
func _build_actions() -> void:
	if not actions_row:
		return
	_clear_children(actions_row)

	if not runmgr or not runmgr.RUN:
		var lbl_no = Label.new()
		lbl_no.text = "Game not running."
		actions_row.add_child(lbl_no)
		return

	# Non-combat UI
	if not runmgr.RUN.has("combat") or not runmgr.RUN.get("combat", null):
		var room_type = str(runmgr.RUN.get("currentRoom", {}).get("type", "none"))

				# Puzzle room UI
		if room_type == "puzzle":
			var puzzle_data : Dictionary = {}
			if runmgr.RUN.has("puzzle"):
				puzzle_data = runmgr.RUN.get("puzzle", {})
			var qtext = "Solve this:"
			if puzzle_data and puzzle_data.get("question", "") != "":
				qtext = str(puzzle_data.get("question", "Solve this:"))

			var vb_puz = VBoxContainer.new()
			vb_puz.set_custom_minimum_size(Vector2(440, 80))

			var qlabel = Label.new()
			qlabel.text = qtext
			qlabel.horizontal_alignment = 1 as HorizontalAlignment
			vb_puz.add_child(qlabel)

			var answer_line = LineEdit.new()
			answer_line.name = "PuzzleAnswer"
			# tooltip_text is the correct property in Godot 4 for hover/help text
			answer_line.tooltip_text = "Type your answer and press Submit"
			answer_line.placeholder_text = "Answer"
			vb_puz.add_child(answer_line)

			var hb_buttons = HBoxContainer.new()
			hb_buttons.set_custom_minimum_size(Vector2(440, 36))

			var submit_btn = Button.new()
			submit_btn.text = "Submit"
			submit_btn.connect("pressed", Callable(self, "_on_puzzle_submit").bind(answer_line))
			hb_buttons.add_child(submit_btn)

			var cancel_btn = Button.new()
			cancel_btn.text = "Close"
			cancel_btn.connect("pressed", Callable(self, "_on_boon_close_pressed"))
			hb_buttons.add_child(cancel_btn)

			vb_puz.add_child(hb_buttons)
			actions_row.add_child(vb_puz)
			return


		# Happening UI
		if room_type == "happening":
			var vb_hap = VBoxContainer.new()
			vb_hap.set_custom_minimum_size(Vector2(440, 80))

			var processed = runmgr.RUN.get("currentRoom", {}).get("processed", false)
			var msg = ""
			if processed:
				msg = "Event already processed. You may continue."
			else:
				msg = "You encountered a spring and recover 10 HP."

			var msg_label = Label.new()
			msg_label.text = str(msg)
			msg_label.horizontal_alignment = 1 as HorizontalAlignment
			vb_hap.add_child(msg_label)

			var hb_hap = HBoxContainer.new()
			hb_hap.set_custom_minimum_size(Vector2(440, 36))

			var next_btn = Button.new()
			next_btn.text = "Next"
			if not next_btn.is_connected("pressed", Callable(self, "_on_next_pressed")):
				next_btn.connect("pressed", Callable(self, "_on_next_pressed"))
			hb_hap.add_child(next_btn)

			vb_hap.add_child(hb_hap)
			actions_row.add_child(vb_hap)
			return

		var lbl_none = Label.new()
		lbl_none.text = "Not a combat room: " + room_type
		actions_row.add_child(lbl_none)
		print("CombatManager: _build_actions(): no combat found. currentRoom type =", room_type)
		return

	# Combat exists from here
	var combat = runmgr.RUN["combat"]
	if not combat:
		var lbl_err = Label.new()
		lbl_err.text = "Combat object invalid."
		actions_row.add_child(lbl_err)
		return

	var tq = combat.get("turnQueue", [])
	var aindex = int(combat.get("activeIndex", 0))
	print("CombatManager: _build_actions() — turnQueue size:", tq.size(), " activeIndex:", aindex)
	for i in range(tq.size()):
		print("  tq[", i, "] =", tq[i])

	var active_entry = null
	if tq.size() > 0 and aindex >= 0 and aindex < tq.size():
		active_entry = tq[aindex]

	# Player turn
	if active_entry != null and str(active_entry.get("type", "")) == "ally":
		var hb_player = HBoxContainer.new()
		hb_player.set_custom_minimum_size(Vector2(480, 52))

		var atk = Button.new()
		atk.text = "Attack"
		atk.set_custom_minimum_size(Vector2(110, 40))
		if not atk.is_connected("pressed", Callable(self, "_on_attack_pressed")):
			atk.connect("pressed", Callable(self, "_on_attack_pressed"))
		hb_player.add_child(atk)

		var ult = Button.new()
		ult.text = "Ultimate"
		ult.set_custom_minimum_size(Vector2(110, 40))
		var hero_energy = 0
		if runmgr.RUN.has("hero") and runmgr.RUN["hero"].has("energy"):
			hero_energy = int(runmgr.RUN["hero"]["energy"])
		if hero_energy < 60:
			ult.disabled = true
		if not ult.is_connected("pressed", Callable(self, "_on_ultimate_pressed")):
			ult.connect("pressed", Callable(self, "_on_ultimate_pressed"))
		hb_player.add_child(ult)

		var guard = Button.new()
		guard.text = "Guard"
		guard.set_custom_minimum_size(Vector2(110, 40))
		if not guard.is_connected("pressed", Callable(self, "_on_guard_pressed")):
			guard.connect("pressed", Callable(self, "_on_guard_pressed"))
		hb_player.add_child(guard)

		var charge = Button.new()
		charge.text = "Charge"
		charge.set_custom_minimum_size(Vector2(110, 40))
		if not charge.is_connected("pressed", Callable(self, "_on_charge_pressed")):
			charge.connect("pressed", Callable(self, "_on_charge_pressed"))
		hb_player.add_child(charge)

		actions_row.add_child(hb_player)
		return

	# Enemy turn
	var lbl = Label.new()
	lbl.text = "Enemy acting..."
	lbl.set_custom_minimum_size(Vector2(220, 32))
	actions_row.add_child(lbl)

	if active_entry != null and str(active_entry.get("type", "")) == "monster":
		var scheduled_enemy_id = str(active_entry.get("id", ""))
		var in_action_flag = false
		if combat.has("inAction"):
			in_action_flag = bool(combat.get("inAction", false))
		var run_in_combat : bool = false
		if runmgr and runmgr.RUN and runmgr.RUN.get("inCombat", false):
			run_in_combat = true
		if not in_action_flag and run_in_combat:
			print("CombatManager: scheduling enemy action for id:", scheduled_enemy_id)
			call_deferred("_call_enemy_after_delay", scheduled_enemy_id)
		else:
			print("CombatManager: NOT scheduling — inAction:", in_action_flag, " run_in_combat:", run_in_combat)


# ---------------- enemy info ----------------
func _on_enemy_info_pressed(enemy_id: String) -> void:
	if not runmgr or not runmgr.RUN or not runmgr.RUN.get("combat", null):
		return

	var found = null
	for ent in runmgr.RUN["combat"].get("enemies", []):
		if str(ent.get("id", "")) == enemy_id:
			found = ent
			break

	if not found:
		if combat_log:
			combat_log.text = str(combat_log.text) + "Enemy not found: %s\n" % [str(enemy_id)]
		else:
			print("CombatManager: Enemy not found: " + str(enemy_id))
		return

	var text = "%s — HP: %d/%d  ATK: %d  DEF: %d\n" % [str(found.get("name", "Enemy")), int(found.get("hp", 0)), int(found.get("maxHp", 0)), int(found.get("atk", 0)), int(found.get("def", 0))]
	if combat_log:
		combat_log.text = str(combat_log.text) + text
	else:
		print(text)


# ---------------- scheduling / execution ----------------
func _call_enemy_after_delay(enemy_id: String) -> void:
	print("CombatManager._call_enemy_after_delay: scheduling start for", enemy_id)
	await get_tree().create_timer(0.45).timeout
	print("CombatManager._call_enemy_after_delay: timer done for", enemy_id)

	if not runmgr or not runmgr.RUN:
		print("CombatManager._call_enemy_after_delay: no runmgr or RUN for", enemy_id)
		return
	if not runmgr.RUN.get("inCombat", false):
		print("CombatManager._call_enemy_after_delay: run not in combat for", enemy_id)
		return
	if not runmgr.RUN.get("combat", null):
		print("CombatManager._call_enemy_after_delay: no combat object for", enemy_id)
		return

	var tgt = null
	for e in runmgr.RUN["combat"].get("enemies", []):
		if str(e.get("id", "")) == enemy_id:
			tgt = e
			break

	if tgt == null:
		print("CombatManager._call_enemy_after_delay: target not found (dead?)", enemy_id)
		_build_actions()
		_update_hud()
		return
	if int(tgt.get("hp", 0)) <= 0:
		print("CombatManager._call_enemy_after_delay: target hp <=0", enemy_id)
		_build_actions()
		_update_hud()
		return

	print("CombatManager._call_enemy_after_delay: calling runmgr.enemy_act for", enemy_id)
	if runmgr and runmgr.RUN and runmgr.RUN.get("inCombat", false) and runmgr.has_method("enemy_act"):
		runmgr.enemy_act(enemy_id)
	else:
		print("CombatManager._call_enemy_after_delay: RunManager.enemy_act missing or run not in combat for:", enemy_id)

	_populate_enemies()
	_build_turn_order()
	_build_actions()
	_update_hud()
	print("CombatManager._call_enemy_after_delay: completed for", enemy_id)


# ---------------- action handlers ----------------
func _on_attack_pressed() -> void:
	if runmgr:
		runmgr.player_attack()
		_after_player_action()

func _on_ultimate_pressed() -> void:
	if runmgr:
		runmgr.player_ultimate()
		_after_player_action()

func _on_guard_pressed() -> void:
	if runmgr:
		runmgr.player_guard()
		_after_player_action()

func _on_charge_pressed() -> void:
	if runmgr:
		runmgr.player_charge()
		_after_player_action()

func _after_player_action() -> void:
	_populate_enemies()
	_build_turn_order()
	_build_actions()
	_update_hud()
	_update_log()


# ---------------- HUD / log ----------------
func _update_hud() -> void:
	if not runmgr or not runmgr.RUN:
		if floor_label:
			floor_label.text = "Floor: -"
		if hp_label:
			hp_label.text = "HP: -"
		if energy_label:
			energy_label.text = "EN: -"
		if top_row:
			var tnode = top_row.get_node_or_null("TargetLabel")
			if tnode:
				tnode.text = "Target: -"
		return

	var hero_data = runmgr.RUN.get("hero", null)
	if hero_data:
		if floor_label:
			floor_label.text = "Floor: %d Room: %d" % [int(runmgr.RUN.get("floor", 0)), int(runmgr.RUN.get("roomIndex", 0))]
		if hp_label:
			hp_label.text = "HP: %d / %d" % [int(hero_data.get("hp", 0)), int(hero_data.get("maxHp", 0))]
		if energy_label:
			energy_label.text = "EN: %d / %d" % [int(hero_data.get("energy", 0)), int(hero_data.get("maxEnergy", 0))]

	var selected_id = null
	if runmgr.RUN.has("combat") and runmgr.RUN["combat"] and runmgr.RUN["combat"].has("selected_target_id"):
		selected_id = runmgr.RUN["combat"].get("selected_target_id", null)

	var target_node = null
	if top_row:
		target_node = top_row.get_node_or_null("TargetLabel")

	if target_node:
		if selected_id:
			var sel_name = " - "
			for ent in runmgr.RUN["combat"].get("enemies", []):
				if str(ent.get("id", "")) == selected_id:
					sel_name = str(ent.get("name", "Enemy"))
					break
			target_node.text = "Target: " + sel_name
		else:
			target_node.text = "Target: -"

	if enemies_row and runmgr and runmgr.RUN and runmgr.RUN.get("combat", null):
		var ecount : int = enemies_row.get_child_count()
		for i in range(ecount):
			var card = enemies_row.get_child(i)
			if not card:
				continue
			var eid = card.get_meta("enemy_id")
			var ent = null
			for d in runmgr.RUN["combat"].get("enemies", []):
				if str(d.get("id", "")) == eid:
					ent = d
					break
			if ent:
				var hp_bar = card.get_node_or_null("InnerVBox/HPBar")
				if hp_bar:
					hp_bar.max_value = float(ent.get("maxHp", 1))
					hp_bar.value = float(ent.get("hp", 0))
				var hp_label_node = card.get_node_or_null("InnerVBox/HPLabel")
				if hp_label_node:
					hp_label_node.text = "HP: %d / %d" % [int(ent.get("hp", 0)), int(ent.get("maxHp", 0))]


func _update_log() -> void:
	if not runmgr or not runmgr.RUN or not runmgr.RUN.get("combat", null):
		if combat_log:
			var rtype = ""
			if runmgr and runmgr.RUN:
				rtype = str(runmgr.RUN.get("currentRoom", {}).get("type", "Explore"))
			combat_log.text = "Explore the Tower. (room: %s)" % [rtype]
		return

	var lines : Array = []
	if runmgr.RUN["combat"].has("logs"):
		lines = runmgr.RUN["combat"].get("logs", [])

	if combat_log:
		var built : String = ""
		for i in range(lines.size()):
			built += str(lines[i]) + "\n"
		combat_log.text = built
		if combat_log.has_method("get_line_count") and combat_log.has_method("cursor_set_line"):
			var last_index : int = int(combat_log.get_line_count()) - 1
			if last_index >= 0:
				combat_log.cursor_set_line(last_index)


# ---------------- Boon handlers (rooted scene) ----------------
func _on_combat_victory_boon() -> void:
	# defensive: only show if runmgr exists and not in combat
	if not runmgr or not runmgr.RUN:
		return
	_show_rooted_boon_panel()

func _on_boon_button_pressed(btn: Button) -> void:
	# bound with .bind(child) in _setup_boon_buttons, so btn is the pressed button
	if not btn:
		print("CombatManager: _on_boon_button_pressed called with null")
		return

	# prefer explicit metadata key "boon_id" (string)
	var boon_id : String = ""
	if btn.has_meta("boon_id"):
		boon_id = str(btn.get_meta("boon_id"))
	else:
		# fallback search parents for metadata
		var p = btn.get_parent()
		while p:
			if p.has_meta("boon_id"):
				boon_id = str(p.get_meta("boon_id"))
				break
			p = p.get_parent()

	# if still missing -> log and ignore (no crash)
	if boon_id == "":
		print("CombatManager: pressed boon button had no 'boon_id' meta; ignoring.")
		if combat_log:
			combat_log.text = str(combat_log.text) + "[SYSTEM] Invalid boon button pressed. No action taken.\n"
		return

	# apply boon
	if runmgr and runmgr.has_method("apply_boon"):
		runmgr.apply_boon(boon_id)
	if runmgr and runmgr.has_method("_push_log"):
		runmgr._push_log("Boon applied: %s" % [boon_id])

	# hide panel and advance
	_hide_rooted_boon_panel()
	# small safe delay before advancing rooms so the player isn't slammed by new enemies immediately
	if runmgr and runmgr.has_method("next_room"):
		await get_tree().create_timer(0.5).timeout
	runmgr.next_room()

	_populate_enemies()
	_build_turn_order()
	_build_actions()
	_update_hud()
	_update_log()

# Close press fallback (if you used a close button)
func _on_boon_close_pressed() -> void:
	_hide_rooted_boon_panel()
	if runmgr and runmgr.has_method("next_room"):
		runmgr.next_room()
	_populate_enemies()
	_build_turn_order()
	_build_actions()
	_update_hud()
	_update_log()


# ---------------- Death return ----------------
func _on_death_return_pressed() -> void:
	# hide death panel if present
	if death_panel:
		death_panel.visible = false

	
	var lobby_path : String = "res://Scenes/Lobby.tscn"
	var mainroot = get_node_or_null("/root/Mainroot")

	# Try to load the lobby scene safely
	var lobby_res = null
	# Use ResourceLoader to avoid crashes; ResourceLoader.load returns null on failure
	lobby_res = ResourceLoader.load(lobby_path)
	if lobby_res and lobby_res is PackedScene:
		var lobby_instance = lobby_res.instantiate()
		# attach to Mainroot so it's in the UI tree
		if mainroot:
			# try to remove any existing old LobbyRoot children first (avoid duplicates)
			var existing = mainroot.get_node_or_null("LobbyRoot")
			if existing:
				existing.queue_free()
			# Make sure the instance is named LobbyRoot if not already
			if lobby_instance.name == "":
				lobby_instance.name = "LobbyRoot"
			mainroot.add_child(lobby_instance)
			# ensure visibility focus
			lobby_instance.visible = true
			# hide CombatRoot (if present)
			var cr = mainroot.get_node_or_null("CombatRoot")
			if cr:
				cr.visible = false
			# re-enable StartRunBtn if present
			var sbtn = mainroot.get_node_or_null("StartRunBtn")
			if sbtn:
				sbtn.disabled = true   # lobby's StartRunBtn will handle starting
			# hide this Combat UI root to avoid input capture
			visible = false
			return
	# fallback: if lobby not found, just toggle TitleScreen (safe)
	if mainroot:
		var t = mainroot.get_node_or_null("TitleScreen")
		var cr2 = mainroot.get_node_or_null("CombatRoot")
		var sbtn2 = mainroot.get_node_or_null("StartRunBtn")
		if t:
			t.visible = true
		if cr2:
			cr2.visible = false
		if sbtn2:
			sbtn2.disabled = false
	visible = false

# ---------------- utilities ----------------
func _clear_children(node: Node) -> void:
	if not node:
		return
	for i in range(node.get_child_count() - 1, -1, -1):
		var c = node.get_child(i)
		if c:
			c.queue_free()
